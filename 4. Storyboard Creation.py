# -*- coding: utf-8 -*-
"""StoryBoard and Image Gen.ipynb

Automatically generated by Colab.

# ───────────────────────────
!pip install --quiet --upgrade openai python-docx pandas ipywidgets slugify tqdm

# ───────────────────────────
# BLOCK 1 — API key & globals
# (full overwrite)
# ───────────────────────────
import os, re, json, base64, textwrap
from pathlib import Path
from slugify import slugify
from functools import partial

import pandas as pd
from tqdm.notebook import tqdm
from IPython.display import display, Image
import ipywidgets as widgets
from google.colab import files

import openai
from dotenv import load_dotenv
load_dotenv()

openai.api_key = os.getenv("OPENAI_API_KEY")

# ----  Constants  ----
MODEL_CHAT  = "gpt-4.1-mini"       # for text prompts / storyboarding
MODEL_IMAGE = "gpt-4o-mini"       # image-generation calls
MAX_PANEL_SECONDS = 10
DEFAULT_SIZE = "1024x1024"
DEFAULT_QUAL = "auto"

STYLE_OPTIONS = [
    # Cartoon / Animation families
    "Adventure Time Whimsical Style",
    "Anime Epic Style",
    "Cel‑Shaded Animation Style",
    "Chibi Cute Style",
    "Claymation Stop‑Motion Style",
    "Comic Pane",
    "Comic Book Pop‑Art Style",
    "Disney Princess Style",
    "Simpsons‑Inspired Cartoon Style",
    "South Park Cut‑Out Style",
    "Vintage 1930s Cartoon Style",
    "Finding Nemo Underwater Style",
    "The Incredibles Superhero Style",
    "Inside Out Emotional Style",
    "Monsters Inc. Style",
    "Pixar General Animation Style",
    "Ratatouille Culinary Style",
    "Shrek Fairy Tale Style",
    "Soul Jazz Aesthetic Style",
    "Toy Story Animation Style",
    "Up Adventure Style",
    "WALL‑E Post‑Apocalyptic Style",
    "LEGO Brick Animation Style",
    "Nintendo Universe Style",
    "Pixel Art Retro Style",
    "Super Mario Style",
    "Voxel/Minecraft Style",
    # Art & Design movements
    "Art Deco Elegance",
    "Art Nouveau Floral Style",
    "Bauhaus Geometric Style",
    "Constructivist Propaganda Style",
    "German Expressionist Style",
    "Impressionist Painting Style",
    "Japanese Ukiyo‑e Style",
    "Memphis Design 80s Style",
    "Mid‑Century Modern Style",
    "Pop Surrealism Style",
    "Russian Constructivism Style",
    # Illustration / graphics
    "Blueprint",
    "Flat Design Infographic Style",
    "Futuristic HUD Style",
    "Isometric Technical Style",
    "Low‑Poly 3D Style",
    "Photorealistic Style",
    "Crayon Children's Drawing Style",
    "Doodle Sketch",
    "Mixed‑Media Collage Style",
    "Mosaic Tile Art Style",
    "Paper Cut‑Out Style",
    "Puppet Theater Style",
    "Sketchbook Doodle Style",
    "Stick Figure / Line Art Style",
    "Watercolor Poster",
    "Woodcut Print Style",
    "Victorian Engraving Style",
    "Letterpress Vintage Type Style",
    "Retro Tech",
    "Risograph Print Style",
    "Chalkboard Classroom Style",
    # Mood / genre
    "Cyberpunk Neon Style",
    "Fairy Tale Illustration Style",
    "Gothic Horror Style",
    "Graffiti Style",
    "Medieval Illuminated Manuscript",
    "New Yorker Cartoon",
    "Film Noir Dramatic Style",
    "VHS Horror",
    "Whiteboard Animation Style",
]

# ───────────────────────────────────────────
#  Detailed descriptors for richer prompts
# ───────────────────────────────────────────
STYLE_DESCRIPTORS = {
    # Cartoon / Animation families
    "Adventure Time Whimsical Style":
        "Bright candy‑coloured palette, thick black outlines, elastic limbs, surreal landscapes.",
    "Anime Epic Style":
        "Dynamic shōnen anime art, dramatic foreshortening, intense cel shading, speed lines.",
    "Cel‑Shaded Animation Style":
        "Bold toon shader, high‑contrast edges, flat colour zones, 3D comic‑look lighting.",
    "Chibi Cute Style":
        "Super‑deformed characters, giant eyes, pastel hues, soft highlights, kawaii expressions.",
    "Claymation Stop‑Motion Style":
        "Hand‑sculpted clay textures, subtle thumbprint imperfections, stage lighting, shallow DOF.",
    "Comic Pane":
        "Single comic panel with inked outlines, halftone dots, dialogue balloon space reserved.",
    "Comic Book Pop‑Art Style":
        "Ben‑Day dots, primary colours, bold onomatopoeia shapes, Roy Lichtenstein vibe.",
    "Disney Princess Style":
        "Classic Disney feature animation, soft rim lighting, delicate line work, fairytale glow.",
    "Simpsons‑Inspired Cartoon Style":
        "Yellow‑skinned characters, thick outlines, simple gradient backgrounds, satirical tone.",
    "South Park Cut‑Out Style":
        "Paper cut‑out shapes, minimal shading, bold flat colours, goofy 2.5‑D staging.",
    "Vintage 1930s Cartoon Style":
        "Rubber‑hose limbs, monochrome ink wash, film grain, bouncing ‘pie‑eye’ characters.",
    "Finding Nemo Underwater Style":
        "Pixar aquatic lighting caustics, saturated reefs, soft volumetric god‑rays, friendly fish.",
    "The Incredibles Superhero Style":
        "Mid‑century modern shapes, saturated reds & yellows, dynamic action poses, stylized shadows.",
    "Inside Out Emotional Style":
        "Glowy particle textures, abstract mind‑scapes, neon gradients reflecting emotions.",
    "Monsters Inc. Style":
        "Fluffy and scaly monster designs, factory setting, colourful doors, soft Pixar lighting.",
    "Pixar General Animation Style":
        "Photorealistic materials + stylized proportions, warm rim light, cinematic depth of field.",
    "Ratatouille Culinary Style":
        "Cozy Parisian kitchens, copper pots, warm ambient bounce light, food‑tastic textures.",
    "Shrek Fairy Tale Style":
        "DreamWorks swamp palette, gritty fairy‑tale set‑dressing, humorous exaggeration.",
    "Soul Jazz Aesthetic Style":
        "Blue‑purple jazz‑club lighting, neon outlines, dreamlike astral backdrops, ethereal glows.",
    "Toy Story Animation Style":
        "Plastic toy materials, suburban bedroom environment, bold primary colours, playful staging.",
    "Up Adventure Style":
        "Soft painterly mattes, colourful balloons, golden‑hour lighting, heartwarming nostalgia.",
    "WALL‑E Post‑Apocalyptic Style":
        "Dusty desaturated earth tones, lonely robot hero, ruined megastructures, hazy sunrise.",
    "LEGO Brick Animation Style":
        "High‑gloss ABS plastic bricks, stud textures, minifig expressions, stop‑motion feel.",
    "Nintendo Universe Style":
        "Colour‑saturated cartoon 3‑D, clean outlines, cheerful vistas reminiscent of Smash Bros levels.",
    "Pixel Art Retro Style":
        "16‑bit console palette, visible square pixels, limited colour ramps, exaggerated sprites.",
    "Super Mario Style":
        "Bright mushroom kingdom palette, round clouds, question‑blocks, cheerful outlook.",
    "Voxel/Minecraft Style":
        "Cube‑based low‑poly world, flat shaded voxels, 1‑metre blocks, simplistic textures.",
    # Art & Design movements
    "Art Deco Elegance":
        "Streamlined geometry, gold & black palette, sunburst motifs, luxurious 1920s glamour.",
    "Art Nouveau Floral Style":
        "Flowing organic lines, pastel lilies & vines, Alfons Mucha poster aesthetic.",
    "Bauhaus Geometric Style":
        "Primary colours, right angles & circles, minimalist sans‑serif typography, functional design.",
    "Constructivist Propaganda Style":
        "Red‑black palette, angular shapes, bold Cyrillic banners, vintage Soviet poster vibe.",
    "German Expressionist Style":
        "High‑contrast chiaroscuro, tilted architecture, dramatic shadows, intense emotional faces.",
    "Impressionist Painting Style":
        "Loose brush strokes, dappled light, plein‑air scenery, Claude Monet colour palette.",
    "Japanese Ukiyo‑e Style":
        "Woodblock print texture, indigo & vermilion inks, flat wave patterns, Edo‑period composition.",
    "Memphis Design 80s Style":
        "Neon squiggles, bold geometric shapes, pastel & neon colours, playful asymmetry.",
    "Mid‑Century Modern Style":
        "Muted retro tones, geometric furniture silhouettes, clean sans‑serif text, atomic age icons.",
    "Pop Surrealism Style":
        "Candy‑coloured dreamscapes, big‑eyed figures, low‑brow art mix of cute & eerie.",
    "Russian Constructivism Style":
        "Bold diagonal layouts, limited palette (reds, blacks, creams), industrial imagery, heavy sans fonts.",
    # Illustration / graphics
    "Blueprint":
        "White technical line art on Prussian‑blue background, measurement grids, schematic style.",
    "Flat Design Infographic Style":
        "Long shadows, saturated flat colours, clean sans text, minimal ornamentation.",
    "Futuristic HUD Style":
        "Glowing cyan vectors on dark glass, concentric circles, sci‑fi data readouts.",
    "Isometric Technical Style":
        "30‑degree isometric grid, pastel engineering diagrams, crisp line work, exploded views.",
    "Low‑Poly 3D Style":
        "Faceted polygons, gradient vertex colours, stylized lighting, simplified meshes.",
    "Photorealistic Style":
        "Physically based rendering, lifelike textures, cinematic lighting, high detail.",
    "Crayon Children's Drawing Style":
        "Waxy strokes, uneven colouring, off‑proportion figures, playful stick sun in corner.",
    "Doodle Sketch":
        "Loose pen doodles, margin scribbles, whimsical icons, notebook paper texture.",
    "Mixed‑Media Collage Style":
        "Cut paper layers, magazine clippings, torn edges, hand‑glued eclectic feel.",
    "Mosaic Tile Art Style":
        "Tiny ceramic tesserae, irregular grout gaps, Byzantine colour palette, shimmering reflections.",
    "Paper Cut‑Out Style":
        "Layered cardstock shadows, smooth paper grain, gentle gradients at edges.",
    "Puppet Theater Style":
        "Fabric textures, wooden stage, jointed marionettes, warm spotlight lighting.",
    "Sketchbook Doodle Style":
        "Pencil sketch lines, cross‑hatching, coffee‑ring stains, spiral‑bound margin.",
    "Stick Figure / Line Art Style":
        "Minimalist stick figures, monochrome lines, simple comic timing.",
    "Watercolor Poster":
        "Soft bleeding pigments, deckled paper edges, light granulation, hand‑lettered title space.",
    "Woodcut Print Style":
        "Heavy black gouged lines, limited colour blocks, traditional relief print texture.",
    "Victorian Engraving Style":
        "Fine cross‑hatching, sepia ink, ornate borders, 19th‑century catalogue illustration.",
    "Letterpress Vintage Type Style":
        "Impressed serif letters, slight ink gain, mis‑registration, tactile paper grain.",
    "Retro Tech":
        "CRT scanlines, chunky plastic bezels, neon grids, early‑80s digital retro‑futurism.",
    "Risograph Print Style":
        "Soy‑ink texture, vibrant spot colours, visible mis‑registration, duplex grain.",
    "Chalkboard Classroom Style":
        "White & coloured chalk strokes, dusty smudges, green slate texture, hand‑drawn arrows.",
    # Mood / genre
    "Cyberpunk Neon Style":
        "Rain‑soaked night city, holographic signs, magenta‑cyan glow, high‑contrast shadows.",
    "Fairy Tale Illustration Style":
        "Whimsical forest palette, ornate illuminated letters, gentle magic particles, storybook charm.",
    "Gothic Horror Style":
        "Grim desaturated tones, pointed arches, candlelit gloom, dramatic silhouettes.",
    "Graffiti Style":
        "Spray‑paint drips, bold outlines, urban brick backdrop, hip‑hop colour splashes.",
    "Medieval Illuminated Manuscript":
        "Gold leaf accents, intricate marginalia, parchment texture, gothic calligraphy.",
    "New Yorker Cartoon":
        "Loose ink line art, understated grayscale wash, witty minimalist composition.",
    "Film Noir Dramatic Style":
        "High‑contrast black‑and‑white, venetian‑blind shadows, cigarette haze, 1940s attire.",
    "VHS Horror":
        "Analog scanlines, slight colour bleed, 4:3 frame, eerie crimson lighting, grainy texture.",
    "Whiteboard Animation Style":
        "Clean black marker lines, stop‑motion erase/re‑draw feel, white background, playful pacing.",
}

# ───────────────────────────
# BLOCK 2 — Upload files
# ───────────────────────────
print("📤  Upload your SCRIPT (.txt or .docx) and the TIMESTAMP CSV …")
uploaded = files.upload()

script_path, csv_path = None, None
for fn in uploaded:
    if fn.lower().endswith((".txt", ".doc", ".docx")):
        script_path = fn
    elif fn.lower().endswith(".csv"):
        csv_path = fn

assert script_path and csv_path, "Missing either the script file or the CSV!"
print("✔️  Received:", script_path, "and", csv_path)

# ───────────────────────────
# BLOCK 3 — Group rows into 5‑15 s storyboard panels
# (full overwrite)
# ───────────────────────────
from docx import Document
import pandas as pd
from pathlib import Path

MIN_SEC = 5
MAX_SEC = 15

def read_script(path: str) -> str:
    if path.lower().endswith(".txt"):
        return Path(path).read_text(encoding="utf-8").strip()
    return "\n".join(p.text for p in Document(path).paragraphs).strip()

script_text = read_script(script_path)

# Load CSV (must contain: sentence,start_s,end_s,duration_s)
df_src = (
    pd.read_csv(csv_path)
      .rename(columns={"start_s": "start", "end_s": "end", "duration_s": "duration"})
      [["sentence", "start", "end", "duration"]]
      .sort_values("start")
      .reset_index(drop=True)
)

panels = []
i = 0
while i < len(df_src):
    # start new panel with current row
    cur_start = df_src.at[i, "start"]
    cur_end   = df_src.at[i, "end"]
    cur_txt   = [df_src.at[i, "sentence"]]
    i += 1

    # keep adding rows if panel < MIN_SEC AND adding next row keeps ≤ MAX_SEC
    while i < len(df_src):
        tentative_end = df_src.at[i, "end"]
        tentative_len = tentative_end - cur_start
        if (cur_end - cur_start) < MIN_SEC and tentative_len <= MAX_SEC:
            cur_end = tentative_end
            cur_txt.append(df_src.at[i, "sentence"])
            i += 1
        else:
            break

    panels.append({
        "Scene": len(panels) + 1,
        "text": " ".join(cur_txt),
        "start": round(cur_start, 2),
        "end":   round(cur_end, 2),
        "duration": round(cur_end - cur_start, 2),
    })

df = pd.DataFrame(panels)

# --- always show full table ---
pd.set_option("display.max_rows", None)   # disable row truncation
display(df)                               # entire storyboard table
print(f"Total storyboard panels: {len(df)}")

# ───────────────────────────
# BLOCK 4 — Choose visual style + size/quality
# (full overwrite)
# ───────────────────────────
import ipywidgets as widgets
from IPython.display import display

style_dd = widgets.Dropdown(
    options=STYLE_OPTIONS,
    description="Style:"
)

size_dd = widgets.Dropdown(
    options=["auto", "1024x1024", "1536x1024", "1024x1536"],
    value=DEFAULT_SIZE,              # feel free to set DEFAULT_SIZE="auto" in Block 1
    description="Size:"
)

qual_dd = widgets.Dropdown(
    options=["auto", "low", "medium", "high"],
    value=DEFAULT_QUAL,
    description="Quality:"
)

display(style_dd, size_dd, qual_dd)

# ───────────────────────────
# BLOCK 5 — Generate a coherent visual prompt list
# (full overwrite)
# ───────────────────────────
import json, textwrap, re

style_label = style_dd.value
style_desc  = STYLE_DESCRIPTORS.get(style_label, style_label)

# ---------- 1. Ask GPT‑4o for *storyboard* scene descriptions ----------
SYSTEM_STORYBOARDER = (
    "You are a storyboard artist. You will receive a numbered list of narration "
    "chunks with accurate timing. For EACH chunk, return a short, vivid IMAGE "
    "DESCRIPTION that advances the story. Maintain visual continuity across frames "
    "(re‑use characters, setting, lighting). Do NOT restate the narration; INSPIRE "
    "the visuals from it. Output a JSON array of strings, same length & order as input."
)

# Build numbered list
narration_list = "\n".join(
    f"{row.Scene}. {row.text}" for _, row in df.iterrows()
)

response = openai.chat.completions.create(
    model=MODEL_CHAT,
    messages=[
        {"role": "system", "content": SYSTEM_STORYBOARDER},
        {"role": "user",   "content": narration_list},
    ],
    temperature=0.7,
)

try:
    scene_desc_list = json.loads(response.choices[0].message.content)
except json.JSONDecodeError:
    # Fallback: split by line if GPT returned plain text lines
    scene_desc_list = [
        re.sub(r"^\d+\.\s*", "", line).strip()
        for line in response.choices[0].message.content.strip().splitlines()
        if line.strip()
    ]

assert len(scene_desc_list) == len(df), "Scene count mismatch from GPT."

# ---------- 2. Build final prompts ----------
def make_prompt(desc: str) -> str:
    return (
        f"{style_desc}\n{desc}\n"
        "Cinematic composition, no text overlays, consistent colour palette."
    )

df["prompt"] = [make_prompt(d) for d in scene_desc_list]

# Preview the full storyboard prompt table
pd.set_option("display.max_rows", None)
display(df[["Scene", "duration", "text", "prompt"]])
print(f"✅  Built {len(df)} coherent image prompts.")

# ───────────────────────────
# BLOCK 6 — Generate images (rugged)
# (full overwrite)
# ───────────────────────────
from base64 import b64decode
from IPython.display import Image, display, HTML
from tqdm.notebook import tqdm

FRAME_DIR = Path("frames"); FRAME_DIR.mkdir(exist_ok=True)

image_paths  = []
failed_idx   = []   # keep track of rows that failed
last_scene_prompt = None

for idx, row in tqdm(df.iterrows(), total=len(df)):
    scene_prompt = row["prompt"]
    if last_scene_prompt:
        scene_prompt += (
            "\nContinue visual style, palette, and framing from the previous frame."
        )

    try:
        resp = openai.responses.create(
            model=MODEL_IMAGE,
            input=scene_prompt,
            tools=[{
                "type": "image_generation",
                "size": size_dd.value,
                "quality": qual_dd.value,
            }],
        )
        img_b64 = resp.output[0].result
        img_bytes = b64decode(img_b64)
        fname = FRAME_DIR / f"scene_{row.Scene:03d}.png"
        with open(fname, "wb") as f:
            f.write(img_bytes)
        image_paths.append(str(fname))
        display(Image(str(fname), width=180))
        last_scene_prompt = scene_prompt
    except openai.OpenAIError as e:
        # log failure, create placeholder
        print(f"⚠️  Scene {row.Scene} failed: {e.error.message[:120]}")
        image_paths.append(None)
        failed_idx.append(idx)
        last_scene_prompt = None  # break continuity chain

# ───────────────────────────
# BLOCK 7 — Gallery + regenerate‑only + Done button
# (full overwrite)
# ───────────────────────────
import base64, ipywidgets as widgets, re
from IPython.display import clear_output, display, HTML
from base64 import b64decode

done_flag = {"ready": False}   # simple mutable flag

# ---------- helpers ----------
def png_data_uri(p):
    with open(p, "rb") as f:
        return "data:image/png;base64," + base64.b64encode(f.read()).decode("ascii")

def show_gallery():
    html = ""
    for idx, p in enumerate(image_paths):
        html += (
            f'<img src="{png_data_uri(p)}" width="140" title="Scene {idx+1}" '
            f'style="margin:4px;border:1px solid #ccc">' if p else
            f'<div style="display:inline-block;width:140px;height:140px;margin:4px;'
            f'background:#fee;border:2px dashed #d33;line-height:140px;text-align:center;'
            f'font-size:12px;">{idx+1}<br>missing</div>'
        )
    display(HTML(html))

def sanitize(p):
    banned = ["blood", "weapon", "violent", "gore"]
    safer = re.sub("|".join(banned), "", p, flags=re.I)
    return safer + "\nFriendly, non‑violent illustration."

def generate(prompt, idx, retry=False):
    try:
        res = openai.responses.create(
            model=MODEL_IMAGE,
            input=prompt,
            tools=[{"type": "image_generation", "size": size_dd.value, "quality": qual_dd.value}],
        )
        img = b64decode(res.output[0].result)
        fname = FRAME_DIR / f"scene_{df.loc[idx,'Scene']:03d}.png"
        with open(fname, "wb") as f: f.write(img)
        image_paths[idx] = str(fname)
        return True, ""
    except openai.OpenAIError as e:
        if not retry and "safety" in e.error.message.lower():
            return generate(sanitize(prompt), idx, retry=True)
        return False, e.error.message[:120]

# ---------- widgets ----------
scene_dd = widgets.Dropdown(
    options=[(f"Scene {row.Scene}", i) for i, row in df.iterrows()],
    description="Scene:", style={"description_width": "55px"}
)
regen_btn = widgets.Button(description="Regenerate", button_style="primary", icon="refresh")
done_btn  = widgets.Button(description="Done", button_style="info", icon="check")

def on_regen(b):
    idx = scene_dd.value
    ok, msg = generate(df.loc[idx,"prompt"], idx)
    clear_output(wait=True)
    print(f"{'✅' if ok else '❌'} Scene {idx+1} {'updated' if ok else 'failed'}{(' — '+msg) if msg else ''}")
    show_gallery(); display(scene_dd, regen_btn, done_btn)

def on_done(b):
    clear_output(wait=True)
    done_flag["ready"] = True
    print("👍  Storyboard locked. Proceed to Block 8 to export assets.")

regen_btn.on_click(on_regen)
done_btn.on_click(on_done)

# ---------- initial UI ----------
show_gallery()
display(scene_dd, regen_btn, done_btn)

# ───────────────────────────
# BLOCK 8 — Save final storyboard & images (UTF‑8 BOM)
# (full overwrite)
# ───────────────────────────
if "done_flag" in globals() and not done_flag.get("ready"):
    raise RuntimeError("Finish editing in Block 7 and click Done before running Block 8.")

# 1. Build CSV
out_csv = "final_storyboard.csv"
df_out = df[["Scene", "start", "end", "duration", "text"]].copy()

# remove internal line‑breaks to keep one row per cell
df_out["text"] = df_out["text"].str.replace(r"[\r\n]+", " ", regex=True).str.strip()

# write with UTF‑8 BOM so Excel / Numbers auto‑detect encoding
df_out.to_csv(out_csv, index=False, encoding="utf-8-sig")
print("✅  Saved storyboard CSV →", out_csv)

# 2. Zip images + CSV
import zipfile, os
zip_name = "video_assets.zip"
with zipfile.ZipFile(zip_name, "w") as z:
    z.write(out_csv)
    for p in image_paths:
        if p and os.path.isfile(p):
            z.write(p)
print("📦  Created asset bundle →", zip_name)