# -*- coding: utf-8 -*-
"""Open AI TTS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wePqH464fQTJJhPszs6K_ovrlUwUQYE4
"""

# ── Cell 1: Install Dependencies ──

!pip install --quiet openai ipywidgets python-docx

# ── Cell 2: Set Your OpenAI API Key ──

import os

# 1) Paste your OpenAI API Key here (keep it secret!)
OPENAI_API_KEY = "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"
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY

# Verify that it’s set correctly:
print("OpenAI Key set:", bool(os.getenv("OPENAI_API_KEY")))

# ── Cell 3: Imports & Initialize OpenAI ──

import io
import openai
import ipywidgets as widgets
from IPython.display import Audio, display
from google.colab import files
from docx import Document  # from python-docx

# Initialize the OpenAI client
openai.api_key = os.getenv("OPENAI_API_KEY")

# ── Cell 4: Define the OpenAI TTS Function ──

def tts_openai_gpt4o(text: str) -> str:
    """
    Send `text` to OpenAI’s Text-to-Speech using model gpt-4o-mini-tts,
    with a default voice ("nova") and speed 1.0. Saves "tts_output.mp3" locally.
    Returns the filename on success, or "" on failure.
    """
    try:
        response = openai.audio.speech.create(
            model="gpt-4o-mini-tts",   # fixed model
            voice="coral",              # default voice
            input=text,
            speed=.95                  # default speed
        )
        output_filename = "tts_output.mp3"
        response.stream_to_file(output_filename)
        return output_filename

    except Exception as e:
        print("Error during OpenAI TTS:", e)
        return ""

# ── Cell 5: Build the User Interface ──

# 1) FileUpload widget (accepts .txt or .docx)
upload_widget = widgets.FileUpload(
    accept='.txt,.docx',
    multiple=False,
    description='Upload .txt/.docx'
)

# 2) TextArea for pasting text
text_area = widgets.Textarea(
    value='',
    placeholder='Or paste your text here (up to 4096 chars)…',
    description='Script:',
    layout=widgets.Layout(width='100%', height='150px')
)

# 3) Button to trigger TTS generation
generate_button = widgets.Button(
    description='Generate Audio',
    button_style='primary'
)

# 4) Output area for status messages and audio preview
output_area = widgets.Output()

# 5) Download button (initially disabled)
download_button = widgets.Button(
    description='Download MP3',
    button_style='success',
    disabled=True
)

# 6) Put all widgets in a vertical box
ui = widgets.VBox([
    widgets.Label("Step 1: Upload a .txt/.docx file OR paste text below:"),
    upload_widget,
    text_area,
    widgets.Label("Step 2: Click to generate audio with gpt-4o-mini-tts:"),
    generate_button,
    output_area,
    download_button
])

# Display the UI
display(ui)

# ── Cell 6: Callback Logic for Generating & Previewing ──

def on_generate_clicked(b):
    output_area.clear_output()
    download_button.disabled = True

    # 1) Determine which text to use (uploaded file has priority)
    text = ""
    if upload_widget.value:
        # Only one file is allowed, so get its name and content
        uploaded_filename = list(upload_widget.value.keys())[0]
        content = upload_widget.value[uploaded_filename]['content']
        # If it’s a .txt:
        if uploaded_filename.lower().endswith('.txt'):
            text = content.decode('utf-8')
        # If it’s a .docx:
        elif uploaded_filename.lower().endswith('.docx'):
            # Load with python-docx
            doc = Document(io.BytesIO(content))
            full_text = []
            for para in doc.paragraphs:
                full_text.append(para.text)
            text = "\n".join(full_text)
        else:
            text = ""
    else:
        text = text_area.value

    # 2) Validate input
    if not text.strip():
        with output_area:
            print("⚠️ No text found. Please upload a .txt/.docx or paste some text.")
        return

    # 3) Enforce 4096-character limit (OpenAI TTS max)
    if len(text) > 4096:
        with output_area:
            print(f"⚠️ Text length is {len(text)} chars; max for OpenAI TTS is 4096.")
        return

    # 4) Call our TTS function
    with output_area:
        print("⏳ Generating audio with gpt-4o-mini-tts…")

    filename = tts_openai_gpt4o(text)

    # 5) If success, preview and enable download
    if filename:
        with output_area:
            display(Audio(filename, autoplay=False))
            print(f"✅ Saved as: {filename}")

        download_button.disabled = False

        # Attach (or re-attach) a click handler for downloading the file
        def on_download_clicked(d):
            files.download(filename)

        # Clear any previous handlers to avoid duplicates
        download_button._click_handlers.callbacks.clear()
        download_button.on_click(on_download_clicked)

    else:
        with output_area:
            print("❌ Failed to generate audio. Check your API key & network.")

# Hook up the button
generate_button.on_click(on_generate_clicked)

